# Assignment One Feedback
## LATE SUBMISSION (SEE GIT LOG)
## Tutor Comment

Good Job. Keep it up. Adding comments to each tasks is a good practice.

## Mark

** 3.42 /5.0**

## Miscellaneous marks

| Level | Requirement | Result |
|:-:|---|:-:|
|P|Forked assignment 1 repository | 0.5/0.5 |
|P|Originality statement edited, committed, pushed | 0.5/0.5 |
|P|Git log file reveals healthy use of Git | 0.25/0.25 |
|P|Edited classes compile correctly | 0.25/0.25 |
|CR|Code is of high quality | 0.2/0.2 |
|HD|Solution is outstanding in its design and implementation | 0.25/0.5 |

**Total for miscellaneous marks:** 1.7/2.2

## Test results
Test Name   Tests Passed  Weighting     Score
-----              -----      -----     -----
task2                3/3        0.2       0.2
task3                4/4        0.2       0.2
task4                3/3        0.2       0.2
task5                4/4        0.2       0.2
task6                3/3        0.2       0.2
task7                7/7        0.1       0.1
task8                4/4        0.1       0.1
task9                6/6        0.1       0.1
task10               3/3       0.25      0.25
task11               2/3       0.25      0.17
task12               0/7        0.5       0.0
task13               0/1        0.5       0.0
-----              -----     Total:  1.72/2.8

## Originality statement
# IMPORTANT: It is very important that you correctly complete this originality
# statement.
#
# This is your statement of your submitted work being your own.
# Incorrectly filling out this statement could lead to charges
# of academic misconduct.
# 
# For information on how to fill this out correctly, see
# https://cs.anu.edu.au/courses/comp1110/help/faq/09-originality/
#

declaration: >-
  I declare that everything I have submitted in this assignment is entirely my
  own work, with the following exceptions:


# Use this to list names of people who you collaborated with, and a
# comment about what you collaborated on.
#
# Add as many "name+comment" entries as necessary
# (or remove it altogether if you haven't collaborated with anyone)


# Use this to list any code that you used that you did not write,
# aside from code provided by the lecturer.  Provide a comment
# explaining your use and the URL to that code and the licence for
# that code
#
# Add as many "url+licence+comment" entries as necessary
# (or remove it altogether if you haven't used any external code)

# Use this to list any assets (artwork, sound, etc) that you used.
# Provide a comment explaining your use of that asset and the URL
# and license for the asset
#
# Add as many "url+licence+comment" entries as necessary
# (or remove it altogether if you haven't used any external assets)



# sign *your* name and uid here
name: Yixi Rao
uid: u6826541
## Git Log
```
commit 18866fffb4839092f119660e3183d33c6d0e3ecd
Author: u6826541 <u6826541@anu.edu.au>
Date:   Fri Aug 9 17:52:20 2019 +1000

    2019 8 9

commit 4405120f0f810db1d00f80a305671a1cf0224687
Author: u6826541 <u6826541@anu.edu.au>
Date:   Fri Aug 9 16:23:42 2019 +1000

    2019 8 9

commit efd4006fdc17b0d79cf76b9957f58d4039665b95
Merge: 2164f43 06052ec
Author: u6826541 <u6826541@anu.edu.au>
Date:   Thu Aug 8 22:34:25 2019 +1000

    Merge branch 'master' of https://gitlab.cecs.anu.edu.au/comp1110/comp1110-ass1

commit 2164f430b6dc746cb689e6702daf658f015a9e98
Author: u6826541 <u6826541@anu.edu.au>
Date:   Thu Aug 8 22:15:32 2019 +1000

    2019 8 8

commit ee287b9c1438cdf802800c27f0d2f782a0833736
Author: u6826541 <u6826541@anu.edu.au>
Date:   Wed Aug 7 23:14:17 2019 +1000

    2019 8 7

commit 13dbd0a65228cc8c4d1125d2e51ffa4c3f04dd06
Author: u6826541 <u6826541@anu.edu.au>
Date:   Wed Aug 7 22:00:43 2019 +1000

    2019 8 7

commit 7374d56c90127a05f3549a40d1e929b882a78d89
Author: u6826541 <u6826541@anu.edu.au>
Date:   Wed Aug 7 14:18:03 2019 +1000

    2019 8 7

commit ee95f245cdafb55872158aaed3aea645224f25f7
Merge: 286c543 431a4ed
Author: u6826541 <u6826541@anu.edu.au>
Date:   Wed Aug 7 14:16:38 2019 +1000

    Merge remote-tracking branch 'origin/master'

commit 431a4edc7accbc31efab277a822d1e837f4f8527
Author: Yixi rao <u6826541@anu.edu.au>
Date:   Wed Aug 7 14:10:16 2019 +1000

    Update originality.yml

commit 90a95be19b69a9185aa4605423d4bf01d4611e22
Author: Yixi rao <u6826541@anu.edu.au>
Date:   Wed Aug 7 14:01:58 2019 +1000

    Update originality.yml

commit 06052ec97e46b8933c7c888260da2cd94e926749
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Tue Aug 6 22:28:34 2019 +1000

    Normalize strings for Task 13

commit de0025a88173331e21f01d878344e081d9261703
Author: Yixi rao <u6826541@anu.edu.au>
Date:   Tue Aug 6 21:58:47 2019 +1000

    Update originality.yml

commit 286c5434ea5c1d439916a9188d48090596dd6894
Author: u6826541 <u6826541@anu.edu.au>
Date:   Tue Aug 6 21:54:56 2019 +1000

    2019 8 6

commit 8ed70033f3cd6c2595ba767271895698c9f9f065
Author: Yixi rao <u6826541@anu.edu.au>
Date:   Tue Aug 6 17:44:21 2019 +1000

    Update originality.yml

commit 3f6b7564a6e5c783c935dae9b36a777da234b7f1
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Tue Aug 6 16:07:26 2019 +1000

    Fix set comparison

commit 7925d01acec4e7ba37279bc2bc11ec411420d1a2
Author: u6826541 <u6826541@anu.edu.au>
Date:   Mon Aug 5 22:08:36 2019 +1000

    2019 8 5

commit a8587592e2d5a183398fde3b841a9e51443468f2
Author: u6826541 <u6826541@anu.edu.au>
Date:   Mon Aug 5 20:52:58 2019 +1000

    2019 8 5

commit 305ee5f9f183f06460f8c4ab4b3508a3e956d9cf
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Fri Aug 2 20:28:50 2019 +1000

    Fix error in encoding of objective 80

commit e7ffe0d9cf2e71a504dd4711c8a19e4f106242d8
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Wed Jul 31 19:25:02 2019 +1000

    Check for completion on rotation.  Thanks to Cui Yu

commit 9da4d4e3c0d65f98ae5ccacdc0374567409a533a
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Tue Jul 30 15:43:53 2019 +1000

    Fix link (thanks to Alexander Cox)

commit 88dc5abded6e5dea4212a554557ccc3f5439739d
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Mon Jul 29 20:44:20 2019 +1000

    Fix CI test name for task 12

commit 2aeb9d11061ade535e7cfe103a77e87cf19aac22
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Sat Jul 27 12:48:26 2019 +1000

    Minor change to paper game

commit 86cd08cec490f3a7cd03417fb7816c5fcda1a5ce
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Sat Jul 27 11:24:11 2019 +1000

    Improve clarity, provide a paper version of the game.

commit 2fdd827e81873f4befbc2f937d1e510d11aeec2a
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Sat Jul 27 10:02:42 2019 +1000

    Improve rotation behavior.  Thanks to Peter Baker.

commit ed939ae08743b9ed1c3b411cd6c5870f084416e4
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Sat Jul 27 10:02:10 2019 +1000

    Typos. Fixes thanks to Peter Baker.

commit 7a55556e9f8fec7c7e55661bf03057d4f9b3ae44
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Fri Jul 26 10:26:57 2019 +1000

    Fix assertion.  Off by one error.  Thanks to Sihan Lin.

commit 18375cd22ed671529d23fcfd973da632025322bd
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Thu Jul 25 22:16:02 2019 +1000

    Fix test for task 13

commit c4a10f85bee6e8c21c9e55c00a84f4b8b38f5654
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Thu Jul 25 19:19:58 2019 +1000

    Typo in objective

commit 5aa536eac70c475c64c8e3a658fbea94da0dfc88
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Thu Jul 25 19:19:51 2019 +1000

    Off-by-one error on difficulty slider

commit 2062a09c867283069bc9c9b3d1f76ef6df64fee0
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Tue Jul 23 15:30:47 2019 +1000

    Fixed assertion

commit 64a0a1a47f46ea551a001942ca565f51018df93a
Author: Josh Milthorpe <josh.milthorpe@anu.edu.au>
Date:   Mon Jul 22 09:49:08 2019 +1000

    3x4 grid

commit 7f5928ee45f5ecab2264bad87d5cf5aab81ec7dd
Author: Josh Milthorpe <josh.milthorpe@anu.edu.au>
Date:   Mon Jul 22 09:26:25 2019 +1000

    fix spelling

commit 6e441d7d188806f7c01e944d424d9bf71b88fee7
Author: Steve Blackburn <steve.blackburn@anu.edu.au>
Date:   Mon Jul 22 00:58:13 2019 +1000

    Initial import
```
## Changes
``` diff
Only in comp1110-ass1: feedback.md
diff -ru -x .git /c/Users/HP/IdeaProjects/comp1110-tutors123/bin/../master/comp1110-ass1/originality.yml comp1110-ass1/originality.yml
--- /c/Users/HP/IdeaProjects/comp1110-tutors123/bin/../master/comp1110-ass1/originality.yml	2019-08-11 14:48:02.674772700 +1000
+++ comp1110-ass1/originality.yml	2019-08-11 19:42:46.575419500 +1000
@@ -19,9 +19,7 @@
 #
 # Add as many "name+comment" entries as necessary
 # (or remove it altogether if you haven't collaborated with anyone)
-collaboration:
-  - name:
-    comment: >-
+
 
 # Use this to list any code that you used that you did not write,
 # aside from code provided by the lecturer.  Provide a comment
@@ -30,10 +28,6 @@
 #
 # Add as many "url+licence+comment" entries as necessary
 # (or remove it altogether if you haven't used any external code)
-code:
-  - comment:
-    url:
-    licence:
 
 # Use this to list any assets (artwork, sound, etc) that you used.
 # Provide a comment explaining your use of that asset and the URL
@@ -41,12 +35,9 @@
 #
 # Add as many "url+licence+comment" entries as necessary
 # (or remove it altogether if you haven't used any external assets)
-assets:
-  - comment:
-    url:
-    licence:
+
 
 
 # sign *your* name and uid here
-name:
-uid:
+name: Yixi Rao
+uid: u6826541
diff -ru -x .git /c/Users/HP/IdeaProjects/comp1110-tutors123/bin/../master/comp1110-ass1/src/comp1110/ass1/Dinosaurs.java comp1110-ass1/src/comp1110/ass1/Dinosaurs.java
--- /c/Users/HP/IdeaProjects/comp1110-tutors123/bin/../master/comp1110-ass1/src/comp1110/ass1/Dinosaurs.java	2019-08-11 14:48:02.678751300 +1000
+++ comp1110-ass1/src/comp1110/ass1/Dinosaurs.java	2019-08-11 19:42:46.580416100 +1000
@@ -1,5 +1,6 @@
 package comp1110.ass1;
 
+import java.util.Arrays;
 import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.Set;
@@ -82,6 +83,7 @@
         for (int i = 0; i < boardState.length()/4; i++) {
             String placement = boardState.substring(i * 4, ((i + 1) * 4));
             addTileToBoard(placement);
+
         }
     }
 
@@ -118,8 +120,21 @@
      * @return  True if the tile is completely within the board, and false otherwise.
      */
     public static boolean isPlacementOnBoard(String placement) {
+        Location l = Tile.placementToLocation(placement);
+        int x = l.getX();
+        int y = l.getY();
+        if (placement.charAt(3) == 'N' ||  placement.charAt(3) == 'S'){
+            if (x + 1 > 4 || y + 2 > 3){
+                return false;
+            }
+        }
+        else {
+            if (x + 2 > 4 || y + 1 > 3){
+                return false;
+            }
+        }
         // FIXME Task 5
-        return false;
+        return true;
     }
 
 
@@ -183,8 +198,25 @@
      * the already placed tiles, and True if there is any overlap.
      */
     public boolean doesPlacementOverlap(String placement) {
-        // FIXME Task 6
+        String state = objective.getInitialState();//use object to get initialstate
+        initializeBoardState(state);
+        Tile t = new Tile(placement);
+        Orientation ori_t = t.getOrientation();
+        int x = t.getLocation().getX();
+        int y = t.getLocation().getY();
+
+        if (ori_t == NORTH || ori_t == SOUTH){
+            if (tiles[y][x] != null || tiles[y+1][x] != null)
+                return true;
+        }
+        else {
+            if (tiles[y][x] != null || tiles[y][x+1] != null ){
+                return true;
+            }
+        }
         return false;
+        // FIXME Task 6
+
     }
 
 
@@ -213,6 +245,50 @@
      * @param tile The tile being placed
      */
     private void updateBoardStates(Tile tile) {
+        int x = tile.getLocation().getX();
+        int y = tile.getLocation().getY();
+        Orientation orientation = tile.getOrientation();
+        TileType type = tile.getTileType();
+        if (orientation == NORTH || orientation == SOUTH){
+            State state0 = type.stateFromOffset(0,0,orientation);
+            boardstates[y][x] = (boardstates[y][x]==GREEN || boardstates[y][x]==RED)?boardstates[y][x]:state0;
+            State state1 = type.stateFromOffset(1,0,orientation);
+            boardstates[y][x+1] = (boardstates[y][x+1]==GREEN || boardstates[y][x+1]==RED)?boardstates[y][x+1]:state1;
+            State state2 = type.stateFromOffset(0,1,orientation);
+            boardstates[y+1][x] = (boardstates[y+1][x]==GREEN || boardstates[y+1][x]==RED)?boardstates[y+1][x]:state2;
+            State state3 = type.stateFromOffset(1,1,orientation);
+            boardstates[y+1][x+1] = (boardstates[y+1][x+1]==GREEN || boardstates[y+1][x+1]==RED)?boardstates[y+1][x+1]:state3;
+            State state4 = type.stateFromOffset(0,2,orientation);
+            boardstates[y+2][x] = (boardstates[y+2][x]==GREEN || boardstates[y+2][x]==RED)?boardstates[y+2][x]:state4;
+            State state5 = type.stateFromOffset(1,2,orientation);
+            boardstates[y+2][x+1] = (boardstates[y+2][x+1]==GREEN || boardstates[y+2][x+1]==RED)?boardstates[y+2][x+1]:state5;
+        }else{
+            State state0 = type.stateFromOffset(0,0,orientation);
+            boardstates[y][x] = (boardstates[y][x]==GREEN || boardstates[y][x]==RED)?boardstates[y][x]:state0;
+            State state1 = type.stateFromOffset(1,0,orientation);
+            boardstates[y][x+1] = (boardstates[y][x+1]==GREEN || boardstates[y][x+1]==RED)?boardstates[y][x+1]:state1;
+            State state2 = type.stateFromOffset(2,0,orientation);
+            boardstates[y][x+2] = (boardstates[y][x+2]==GREEN || boardstates[y][x+2]==RED)?boardstates[y][x+2]:state2;
+            State state3 = type.stateFromOffset(0,1,orientation);
+            boardstates[y+1][x] = (boardstates[y+1][x]==GREEN || boardstates[y+1][x]==RED)?boardstates[y+1][x]:state3;
+            State state4 = type.stateFromOffset(1,1,orientation);
+            boardstates[y+1][x+1] = (boardstates[y+1][x+1]==GREEN || boardstates[y+1][x+1]==RED)?boardstates[y+1][x+1]:state4;
+            State state5 = type.stateFromOffset(2,1,orientation);
+            boardstates[y+1][x+2] = (boardstates[y+1][x+2]==GREEN || boardstates[y+1][x+2]==RED)?boardstates[y+1][x+2]:state5;
+
+        }
+
+        //State state = type.stateFromOffset(location.getX(),location.getY(),orientation);
+        //boardstates[location.getX()][location.getY()] = state;
+
+
+
+
+
+
+
+
+
         // FIXME Task 7 (part I)
     }
 
@@ -234,8 +310,15 @@
      * the given location.
      */
     public State getLocationState(Location location) {
+        int x = location.getX();
+        int y = location.getY();
+        return boardstates[y][x];
+
+
+
+
         // FIXME Task 7 (part II)
-        return null;
+
     }
 
     /**
@@ -261,8 +344,58 @@
      * tiles, and False if it is inconsistent.
      */
     public boolean isPlacementConsistent(String placement) {
+        Tile tile = new Tile(placement);
+        Orientation orientation = tile.getOrientation();
+        TileType type = tile.getTileType();
+        int x = tile.getLocation().getX();
+        int y = tile.getLocation().getY();
+
+        if (orientation == NORTH || orientation == SOUTH){
+            State[] states = {type.stateFromOffset(0,0,orientation),type.stateFromOffset(1,0,orientation),
+                              type.stateFromOffset(0,1,orientation),type.stateFromOffset(1,1,orientation),
+                              type.stateFromOffset(0,2,orientation),type.stateFromOffset(1,2,orientation)};
+            State[] states1 = {boardstates[y][x],boardstates[y][x+1],
+                               boardstates[y+1][x],boardstates[y+1][x+1],
+                               boardstates[y+2][x],boardstates[y+2][x+1]};
+            for (int i = 0;i < states.length;i++){
+                if (judgeIsland(states[i],states1[i]) == false){
+                    return false;
+                }
+            }
+        }
+        else {
+                    State[] states = {type.stateFromOffset(0,0,orientation),type.stateFromOffset(1,0,orientation), type.stateFromOffset(2,0,orientation),
+                            type.stateFromOffset(0,1,orientation), type.stateFromOffset(1,1,orientation),type.stateFromOffset(2,1,orientation)};
+                    State[] states1 = {boardstates[y][x],boardstates[y][x+1], boardstates[y][x+2],
+                            boardstates[y+1][x], boardstates[y+1][x+1],boardstates[y+1][x+2]};
+                    for (int i = 0;i < states.length;i++){
+                        if (judgeIsland(states[i],states1[i]) == false){
+                            return false;
+                        }
+            }
+        }
+
         // FIXME Task 9
-        return false;
+        return true;
+    }
+    public static boolean judgeIsland(State s1,State s2){
+        if (s1 == WATER){
+            if (s2 == WATER){
+                return true;
+            }
+            else {
+                return false;
+            }
+        }
+        else {
+            if (s2 == WATER){
+                return false;
+            }
+            else {
+                return true;
+            }
+
+        }
     }
 
     /**
@@ -275,9 +408,46 @@
      * between red and green dinosaurs.
      */
     public boolean isPlacementDangerous(String placement) {
+        Tile tile = new Tile(placement);
+        Orientation orientation = tile.getOrientation();
+        TileType type = tile.getTileType();
+        int x = tile.getLocation().getX();
+        int y = tile.getLocation().getY();
+        if (orientation == NORTH || orientation == SOUTH){
+            State[] states = {type.stateFromOffset(0,0,orientation),type.stateFromOffset(1,0,orientation),
+                              type.stateFromOffset(0,1,orientation),type.stateFromOffset(1,1,orientation),
+                              type.stateFromOffset(0,2,orientation),type.stateFromOffset(1,2,orientation)};
+            State[] states1 = {boardstates[y][x],boardstates[y][x+1],
+                               boardstates[y+1][x],boardstates[y+1][x+1],
+                               boardstates[y+2][x],boardstates[y+2][x+1]};
+            for (int i = 0;i < states.length;i++){
+                if (judgeDinosaurs(states[i],states1[i]) == true){
+                    return true;
+                }
+            }
+        }
+        else {
+            State[] states = {type.stateFromOffset(0,0,orientation),type.stateFromOffset(1,0,orientation), type.stateFromOffset(2,0,orientation),
+                    type.stateFromOffset(0,1,orientation), type.stateFromOffset(1,1,orientation),type.stateFromOffset(2,1,orientation)};
+            State[] states1 = {boardstates[y][x],boardstates[y][x+1], boardstates[y][x+2],
+                    boardstates[y+1][x], boardstates[y+1][x+1],boardstates[y+1][x+2]};
+            for (int i = 0;i < states.length;i++){
+                if (judgeDinosaurs(states[i],states1[i]) == true){
+                    return true;
+                }
+            }
+        }
         // FIXME Task 10
         return false;
     }
+    public static Boolean judgeDinosaurs(State s1,State s2){
+        if ((s1 == GREEN && s2 == RED)||(s1 == RED && s2 == GREEN )){
+            return true;
+        }
+        else {
+            return false;
+        }
+    }
 
     /**
      * Check whether the given tile placement violates the game objective,
@@ -293,9 +463,146 @@
      * and false otherwise.
      */
     public boolean violatesObjective(String placement) {
-        // FIXME Task 11
+        if (isPlacementConsistent(placement) == false ){
+            return true;
+        }
+        Tile tile = new Tile(placement);
+        addTileToBoard(placement);
+        String connective = objective.getConnectedIslands();
+        String initial = objective.getInitialState();
+        String[] states = new String[(initial.length()/4)];
+        for (int i = 0; i < initial.length()/4; i++){
+            String state = initial.substring(i * 4, ((i + 1) * 4));
+            states[i] = state;
+        }
+        for (int i = 0; i < connective.length()/4; i++){
+            String twoRequire = connective.substring(i * 4, ((i + 1) * 4));
+            if (crossOri(connectiveLocation(twoRequire.charAt(0)),connectiveLocation(twoRequire.charAt(1)),connectiveLocation(twoRequire.charAt(2)),connectiveLocation(twoRequire.charAt(3)))== null){
+                continue;
+            }
+            State s1 = boardstates[connectiveLocation(twoRequire.charAt(1))][connectiveLocation(twoRequire.charAt(0))];
+            State s2 = boardstates[connectiveLocation(twoRequire.charAt(3))][connectiveLocation(twoRequire.charAt(2))];
+            if ((s1 == GREEN && s2 == EMPTY)||(s1 == RED && s2 == EMPTY)||(s2 == GREEN && s1 == EMPTY)||(s2 == RED && s1 == EMPTY)){
+                return  true;
+            }
+            for (String j :states) {
+                if (stateConnective(j).equals("")){
+                    return true;
+                }
+                if (connective.indexOf(stateConnective(j)) == -1 )
+                    return true;
+            }
+        }
         return false;
     }
+        // FIXME Task 11
+
+
+    public Tile crossOri(int x1,int y1,int x2,int y2) {
+        if (x1 < x2 && y1 < y2) {
+            return tiles[y1][x1];
+        }
+        else if (x1 > x2 && y1 > y2) {
+            return tiles[y2][x2];
+        }
+        else if (x1 > x2 && y1 < y2){
+            return tiles[y1][x1-1];
+        }
+        else {
+            return tiles[y1-1][x1];
+        }
+
+    }
+    public static int connectiveLocation(char c){
+        int x = 0;
+        switch (c){
+            case '0':
+                x = 0;break;
+            case '1':
+                x = 1;break;
+            case '2':
+                x = 2;break;
+            case '3':
+                x = 3;break;
+            case '4':
+                x = 4;break;
+        }
+        return x;
+    }
+    public String stateConnective(String s1){
+        Tile tile = new Tile(s1);
+        TileType type = tile.getTileType();
+        Orientation o = tile.getOrientation();
+        int x = tile.getLocation().getX();
+        int y = tile.getLocation().getY();
+        String k = "";
+        switch (type){
+            case A:
+                return "";
+            case B:
+                switch (o){
+                    case NORTH:
+                        k=""+x+1+""+y+""+x+""+y+1+""+x+""+y+1+""+x+1+""+y+2;break;
+                    case SOUTH:
+                        k=""+x+""+y+""+x+1+""+y+1+""+x+1+""+y+1+""+x+""+y+2;break;
+                    case EAST:
+                        k=""+x+1+""+y+""+x+""+y+1+""+x+1+""+y+""+x+2+""+y+1;break;
+                    case WEST:
+                        k=""+x+""+y+""+x+1+""+y+1+""+x+2+""+y+""+x+1+""+y+1;break;
+                }
+                break;
+            case C:
+                switch (o){
+                    case NORTH:
+                        k=""+x+""+y+""+x+1+""+y+1+"";break;
+                    case SOUTH:
+                        k=""+x+""+y+1+""+x+1+""+y+2+"";break;
+                    case EAST:
+                        k=""+x+2+""+y+""+x+1+""+y+1+"";break;
+                    case WEST:
+                        k=""+x+1+""+y+""+x+""+y+1+"";break;
+                }break;
+            case D:{
+                switch (o){
+                    case NORTH:
+                        k=""+x+""+y+""+x+1+""+y+1+"";break;
+                    case SOUTH:
+                        k=""+x+""+y+1+""+x+1+""+y+2+"";break;
+                    case EAST:
+                        k=""+x+2+""+y+""+x+1+""+y+1+"";break;
+                    case WEST:
+                        k=""+x+1+""+y+""+x+""+y+1+"";break;
+                }
+            }
+            break;
+            case E:{
+                switch (o){
+                    case NORTH:
+                        return k=""+x+1+""+y+1+""+x+2+""+y+"";
+                    case SOUTH:
+                        return k=""+x+1+""+y+""+x+""+y+1+"";
+                    case EAST:
+                        return k=""+x+""+y+""+x+1+""+y+1+"";
+                    case WEST:
+                        return k=""+x+1+""+y+""+x+2+""+y+1+"";
+                }
+            }
+            break;
+            case F:{
+                switch (o){
+                    case NORTH:
+                        return k=""+x+1+""+y+""+x+""+y+1+"";
+                    case SOUTH:
+                        return k=""+x+1+""+y+1+""+x+""+y+2+"";
+                    case EAST:
+                        return k=""+x+1+""+y+""+x+2+""+y+1+"";
+                    case WEST:
+                        return k=""+x+""+y+""+x+1+""+y+1+"";
+                }
+            }
+        }
+        return k;
+    }
 
     /**
      * Given a target location, find the set of actions which:
@@ -310,6 +617,8 @@
      * @return A set of strings, each representing a tile placement
      */
     public Set<String> findCandidatePlacements(Location targetLoc) {
+        String connective = objective.getConnectedIslands();
+        String initial = objective.getInitialState();
         // FIXME Task 12
         return new HashSet<>();
     }
diff -ru -x .git /c/Users/HP/IdeaProjects/comp1110-tutors123/bin/../master/comp1110-ass1/src/comp1110/ass1/Objective.java comp1110-ass1/src/comp1110/ass1/Objective.java
--- /c/Users/HP/IdeaProjects/comp1110-tutors123/bin/../master/comp1110-ass1/src/comp1110/ass1/Objective.java	2019-08-11 14:48:02.680749000 +1000
+++ comp1110-ass1/src/comp1110/ass1/Objective.java	2019-08-11 19:42:46.582415700 +1000
@@ -1,5 +1,7 @@
 package comp1110.ass1;
 
+import java.util.Random;
+
 /**
  * An objective defines what the player must attempt to solve.   It is expressed
  * in terms of two parts:
@@ -380,8 +382,25 @@
      */
     public static Objective newObjective(int difficulty) {
         assert difficulty >= 0 && difficulty <= 3;
+        int num=0;
+        Random r = new Random();
+        switch (difficulty){
+            case 0:
+                num = r.nextInt(20);
+                break;
+            case 1:
+                num = 20 + r.nextInt(20);
+                break;
+            case 2:
+                num = 40 + r.nextInt(20);
+                break;
+            case 3:
+                num = 60 + r.nextInt(20);
+                break;
+
+        }
 
-        return OBJECTIVES[0]; // FIXME Task 8
+        return OBJECTIVES[num]; // FIXME Task 8
     }
 
     public String getConnectedIslands() {
diff -ru -x .git /c/Users/HP/IdeaProjects/comp1110-tutors123/bin/../master/comp1110-ass1/src/comp1110/ass1/Orientation.java comp1110-ass1/src/comp1110/ass1/Orientation.java
--- /c/Users/HP/IdeaProjects/comp1110-tutors123/bin/../master/comp1110-ass1/src/comp1110/ass1/Orientation.java	2019-08-11 14:48:02.681748300 +1000
+++ comp1110-ass1/src/comp1110/ass1/Orientation.java	2019-08-11 19:42:46.584413800 +1000
@@ -2,7 +2,6 @@
 
 public enum Orientation {
     NORTH, EAST, SOUTH, WEST;
-
     /**
      * Return the single character associated with a `Orientation`, which is the first character of
      * the direction name, as an upper case character ('N', 'E', 'S', 'W')
@@ -10,7 +9,20 @@
      * @return A char value equivalent to the `Orientation` enum
      */
     public char toChar() {
+        if (this == NORTH){
+            return 'N';
+
+        }
+        else if (this == EAST){
+            return 'E';
+        }
+        else if (this == SOUTH){
+            return 'S';
+        }
+        else{
+            return 'W';
+        }
         // FIXME Task 2
-        return 'N';
+
     }
 }
diff -ru -x .git /c/Users/HP/IdeaProjects/comp1110-tutors123/bin/../master/comp1110-ass1/src/comp1110/ass1/Tile.java comp1110-ass1/src/comp1110/ass1/Tile.java
--- /c/Users/HP/IdeaProjects/comp1110-tutors123/bin/../master/comp1110-ass1/src/comp1110/ass1/Tile.java	2019-08-11 14:48:02.683747800 +1000
+++ comp1110-ass1/src/comp1110/ass1/Tile.java	2019-08-11 19:42:46.587415000 +1000
@@ -1,6 +1,6 @@
 package comp1110.ass1;
 
-import static comp1110.ass1.Orientation.NORTH;
+import static comp1110.ass1.Orientation.*;
 
 public class Tile {
 
@@ -32,8 +32,17 @@
      * @return A value of type `Orientation` corresponding to the tile's orientation on board
      */
     public static Orientation placementToOrientation(String placement) {
+        if (placement.charAt(3) == 'N'){
+            return NORTH;
+        }
+        else if (placement.charAt(3) == 'S')
+            return SOUTH;
+        else if (placement.charAt(3) == 'W')
+            return WEST;
+        else
+            return EAST;
         // FIXME Task 3
-        return NORTH;
+
     }
 
     /**
@@ -46,7 +55,33 @@
      * @return A value of type `Location` corresponding to the tile's location on the board
      */
     public static Location placementToLocation(String placement) {
+        int x = 0;
+        switch (placement.charAt(1)){
+            case '0':
+                x = 0;break;
+            case '1':
+                x = 1;break;
+            case '2':
+                x = 2;break;
+            case '3':
+                x = 3;break;
+            case '4':
+                x = 4;break;
+        }
+        int y=0;
+        switch (placement.charAt(2)){
+            case '0':
+                y = 0;break;
+            case '1':
+                y = 1;break;
+            case '2':
+                y = 2;break;
+            case '3':
+                y = 3;break;
+        }
+        return new Location(x,y);
+
         // FIXME Task 4
-       return new Location(0, 0);
+
     }
 }
```
